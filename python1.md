### 为什么列表生成式比for循环快

- 列表生成式是一次生成所有数据，再将这些数据放入列表中
- for循环是一个一个生成数据，并将这些数据append到末尾，因此效率更低
- 但面对超大循环次数时，一次生成全部数据的列表生成式会非常占用内存

### 为什么ndarray快于list

- ndarray存储的数据类型是相同的，list是不同的
- 因此对于前者来说，其底层内存的地址及数据是连续的，而list存放的是每一个元素的地址
- 对于批量操作某一块数据来说，ndarray要快得多
- 其二：ndarray底层是由C编写，去除了Python本身的GIL锁，当进行大批量运算时，底层会自动进行并发运算

### 类方法、静态方法，

- 类方法通过装饰器@classmethod来定义
  - 类方法真正属于类，在实例对象中不会有任何相关信息
  - 使用场景：需要使用类对象 (如访问私有类属性等)时，定义类方法
- 静态方法通过装饰器@staticmethod来定义
  - 使用场景：方法中 既不需要使用实例对象(如实例对象，实例属性)，也不需要使用类对象 (如类属性、类方法、创建实例等)时，定义静态方法
  - 取消不需要的参数传递，有利于减少不必要的内存占用和性能消耗
- 类方法和静态方法中访问实例属性和实例方法会导致错误


### 全局变量、局部变量、实例变量、静态变量

- 全局变量：在模块内、在所有函数外面、在class外面，这就是全局变量
- 静态变量：在class内的，但不在class的方法内的，这就是静态变量（类变量？）
- 局部变量：在函数内、在class的方法内（未加self修饰）
- 实例变量：在class的方法内的，用self修饰的变量

### 为什么会有 GIL 锁？

- 由于 GIL 的存在，即使是多个线程处理任务，但是最终也只有一个线程在工作，那么是不是多线程真的一点用处都没有呢？
- 对于需要执行的任务来说，分为两种：计算密集型、IO 密集型
- 线程遇到I/O阻塞时，会释放GIL
- 在I/O密集时，多线程是很有必要的
- 多线程是解决IO阻塞问题和IO占用时CPU闲置问题
- 结论：多线程使程序交替轮番执行，不会对后边的程序产生阻塞（这才是python应用多线程的根本目的）
- 所以如果运行瓶颈不在CPU运算而是在IO（网络）上，多线程显然很划算

### GIL锁是python特有的吗

- GIL并不是Python的特性，Python完全可以不依赖于GIL
- 它是在实现Python解析器(CPython)时所引入的一个概念
- Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行
- 像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境
- 所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷
